import { NamedCodeBlock } from '~/components/atoms'

export const meta = {
  title: 'Vue3 を先取り Compositon API と direct-vuex を使って TypeScript に対応する',
  tags: ['Vue.js', 'TypeScript', 'Composition API', 'Vuex'],
  publishDate: '2020-06-20',
  modifiedDate: false,
  seoDescription: '',
  exclude: false
}

Vue3 のリリースが 2020 Q2 に伸びていました。
普段 React + TypeScript で開発しているので Vue3 の Composition API や TypeScript 対応に期待していて、
SFCがエディタと相性悪い、TypeScriptで補完が効かないと悩まされてたあの頃がもう昔のことのように感じます。

Vue3でリリース予定に機能には Composition API, Fragment, Portal, Suspence などがあり React に寄せてきたなって印象です。
Composition API は React Hooks ライクな機能でコンポーネントからロジックの分離がしやすくなります。

そんな Vue3 リリース間近に Vue を書く機会が訪れたので Vue2 向けに公開されている Composition API を入れて Vue3 を先取りするための環境を作っていきます。

# Composition API とは

実は公式から Vue2 向けの Composition API が公開されていて Vue3 を待たなくても使えます。
npm もしくは yarn から @vue/composition-api をインストールしてください。

```bash
npm install @vue/composition-api
yarn add @vue/composition-api
```

<NamedCodeBlock filename="従来のコンポーネント定義">

```html
<script lang="ts">
import Vue from 'vue'

export default Vue.extend({
  created() {
    console.log('created')
  }
})
</script>
```

</NamedCodeBlock>

<NamedCodeBlock filename="Composition API を使ったコンポーネント定義">

```html
<script lang="ts">
import { defineComponent } from '@vue/composition-api'

export default defineComponent({
  setup() {
    console.log('setup')
  }
})
</script>
```

</NamedCodeBlock>

これだけ見ると created が setup に置き換わっただけに見えますが、これまで data, created, methods, watch のように分かれていたものを setup でまとめて定義するようになりました。
setup ひとつになったことで data で定義した値の型が created からわからないといったことがなくなります。

## リアクティブな値

reactive, ref

computed
deep

の説明を書く

## ライフサイクルメソッド

onBeforeMount, onBeforeUpdate, onBeforeUnmount, onUnmounted, onErrorCaptured

の説明を書く

# direct-vuex を使ったTodoアプリの実装

Composition API だけでは Vuex の型がコンポーネント側で分かりません。Vuex は TypeScript と相性が悪いとよく言われていてそれを解決するためのライブラリがいくつか公開されているのですが、
direct-vuex というものを見つけたので今回はこれを使っていきます。

 @vue/composition-api 同様に npm もしくは yarn からインストールします。

```bash
npm install direct-vuex
yarn add direct-vuex
```

Vue CLI などでプロジェクトを作ると store/index.ts が用意されていますがこれを編集していきます。

Vuex.Store の代わりに createDirectStore を使ってストアを作成します。
state を toRefs(reactive()) で囲んでいるのは Composition API で作ったコンポーネントに渡した際に state の更新を検知するために囲んでいます。

<NamedCodeBlock filename="/src/store/index.ts">

```typescript
import Vue from 'vue'
import Vuex from 'vuex'
import VueCompositionAPI, { reactive, toRefs } from '@vue/composition-api'
import { createDirectStore } from 'direct-vuex'

Vue.use(VueCompositionAPI)
Vue.use(Vuex)

export type TodoItem = {
  id: number
  text: string
  isComplete: boolean
}

const initialState = {
  todoList: [] as TodoItem[],
}

const { store, rootActionContext, moduleActionContext } = createDirectStore({
  state: toRefs(reactive(initialState)),
  getters: {
    allTodoList: state => state.todoList.value,
  },
  mutations: {
    updateTodoList(state, payload: TodoItem[]) {
      state.todoList.value = payload
    },
  },
  actions: {
    addTodoItem({ state, commit }, payload: TodoItem) {
      const todoList = [...state.todoList.value, payload] as TodoItem[]

      commit('updateTodoList', todoList)
    },
    editTodoItem({ state, commit }, payload: TodoItem) {
      const todoList = state.todoList.value as TodoItem[]
      const editedTodoList = todoList.map(item =>
        item.id === payload.id ? payload : item
      )

      commit('updateTodoList', editedTodoList)
    },
    removeTodoItem({ state, commit }, id: number) {
      const todoList = state.todoList.value as TodoItem[]
      const removedTodoList = todoList.filter(item => item.id !== id)

      commit('updateTodoList', removedTodoList)
    },
  },
})

export default store

export { rootActionContext, moduleActionContext }

export type AppStore = typeof store

declare module 'vuex' {
  interface Store<S> {
    direct: AppStore
  }
}

```

</NamedCodeBlock>

TodoList コンポーネントを作成します。this.$store からだとストアの型が取得できないので import してきた store を直接使います。
これを実現してるのが direct-vuex で store の型補完が効いていて store.getters.allTodoList のようにエディタが補完してくれるのが確認できます。

<NamedCodeBlock filename="/src/components/TodoList.vue">

```vue
<template>
  <div>
    <TodoItemCreator />

    <TodoItem
      v-for="todoItem in todoList"
      :item="todoItem"
      :key="todoItem.id"
    />
  </div>
</template>

<script lang="ts">
import { defineComponent, computed } from '@vue/composition-api'

import store from '@/store'

import TodoItemCreator from '@/components/TodoItemCreator.vue'
import TodoItem from '@/components/TodoItem.vue'

export default defineComponent({
  setup() {
    const todoList = computed(() => store.getters.allTodoList)

    return {
      todoList,
    }
  },
  components: {
    TodoItemCreator,
    TodoItem,
  },
})
</script>

```

</NamedCodeBlock>

同様に TodoItem, TodoItemCreator コンポーネントも作っていきます。

<NamedCodeBlock filename="/src/components/TodoItem.vue">

```vue
<template>
  <div>
    <input type="text" v-model="todoItem.text" @change="editItemText()" />
    <input
      type="checkbox"
      v-model="item.isComplete"
      @change="toggleItemCompletion()"
    />
    <button @click="deleteItem()">X</button>
  </div>
</template>

<script lang="ts">
import { defineComponent, reactive } from '@vue/composition-api'

import store, { TodoItem } from '@/store'

export default defineComponent({
  props: {
    item: {
      type: (Object as any) as () => TodoItem,
      required: true,
    },
  },
  setup(props) {
    const todoItem = reactive({ ...props.item })

    const editItemText = () => {
      store.dispatch.editTodoItem(todoItem)
    }

    const toggleItemCompletion = () => {
      store.dispatch.editTodoItem(todoItem)
    }

    const deleteItem = () => {
      store.dispatch.removeTodoItem(todoItem.id)
    }

    return {
      todoItem,
      editItemText,
      toggleItemCompletion,
      deleteItem,
    }
  },
})
</script>

```

</NamedCodeBlock>


<NamedCodeBlock filename="/src/components/TodoItemCreator.vue">

```vue
<template>
  <div>
    <input type="text" v-model="newItem.text" />
    <button @click="addItem()">Add</button>
  </div>
</template>

<script lang="ts">
import { defineComponent, reactive } from '@vue/composition-api'

import store from '@/store'

export default defineComponent({
  setup() {
    const newItem = reactive({ index: 0, text: '' })

    const addItem = () => {
      newItem.index += 1

      store.dispatch.addTodoItem({
        id: newItem.index,
        text: newItem.text,
        isComplete: false,
      })

      newItem.text = ''
    }

    return {
      newItem,
      addItem,
    }
  },
})
</script>

```

</NamedCodeBlock>

これで簡単なTodoアプリが完成しました。


# まとめ
無事 TypeScript に完全対応できました。
Vuex は direct-vuex で、 Template は VS Code なら Vetur で型補完が効くようになり不便を感じることはなくなりました。
TypeScript 対応にフォーカスして解説しましたが、Composition API は React Hooks に近い書き方ができるので React 経験が長い自分には馴染みやすいものでした。
過去に React Hooks が公開された直後 Evan氏が Vue Hooks をテスト実装したこともありそれぞれの良い部分を吸収してるように感じます。

この記事のコードは GitHub で公開しています。

https://github.com/ria3100/vue2-composition-api-example
